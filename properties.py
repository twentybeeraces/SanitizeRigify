import bpy

def is_armature_object(self, object):
    """ returns True if object type is armature """
    return object.type == 'ARMATURE'

def is_mesh_object(self, object):
    """ returns True if object type is mesh """
    return object.type == 'MESH'

def is_rigify(self, object):
    """ returns True if object is rigify rig (generated rig, not metarig) """
    return is_armature_object(self, object) and AddonPreferences.rigify_id_prop_name in object.data.keys()

def is_generated_rig(self, object):
    """ returns True if object is a game-ready rig (is/was generated by this addon) """
    if is_armature_object(self, object) and object.sr_origin:
        return True
    return False

def is_parented_mesh(self, object):
    """ returns True if object is a mesh parented to either any rigify rig, or any generated game-ready rig """
    if is_mesh_object(None, object):
        if object.parent:
            return is_rigify(None, object.parent) or is_generated_rig(None, object.parent)
    return False

@bpy.app.handlers.persistent
def depsgraph_update_handler(scene):
    if bpy.context.object is None:
        scene.sr_current_rigify = None
        return
    # check if rigify (control) rig
    if is_rigify(None, bpy.context.object):
        scene.sr_current_rigify = bpy.context.object
        return
    # check if generated rig
    if is_generated_rig(None, bpy.context.object):
        scene.sr_current_rigify = bpy.context.object.sr_origin
        return
    # check if a mesh parented to either
    if is_parented_mesh(None, bpy.context.object):
        # parented to generated rig
        if is_generated_rig(None, bpy.context.object.parent):
            scene.sr_current_rigify = bpy.context.object.parent.sr_origin
            return
        # parented to rigify
        scene.sr_current_rigify = bpy.context.object.parent
        return
    # other
    scene.sr_current_rigify = None
    return
    

class AddonPreferences(bpy.types.AddonPreferences):
    """ General addon settings """
    bl_idname = __package__
    # rigify constants
    rigify_id_prop_name = "rig_id"
    ORG_prefix = "ORG-"
    DEF_prefix = "DEF-"
    MCH_prefix = "MCH-"
    VIS_prefix = "VIS_"
    # addon constants
    prefix = "sr_"
    collection_name = "SanitizeRigify"
    export_scale = 0.01
    # settings
    def update_armature_name(self, context):
        if self.default_armature_name == "":
            self.default_armature_name = "Armature"
    default_armature_name : bpy.props.StringProperty(name = "Default armature name", description = "Default name of exported armatures", default = "Armature", update = update_armature_name)
    allow_export_without_preview : bpy.props.BoolProperty(name = "Allow export without preview", description = "Enable to allow directly exporting without previewing", default = False)
    
    def draw(self, context):
        layout = self.layout
        row = layout.row()
        row.label(text = "Default armature name")
        row.prop(self, "default_armature_name", text ="")
        row = layout.row()
        row.label(text = "Allow export without preview")
        row.prop(self, "allow_export_without_preview", text = "")

class SanitizeRigifyBoneProperty(bpy.types.PropertyGroup):
    """
    Bone property in list of bones
    """
    name : bpy.props.StringProperty(name="Bone name", override = {'LIBRARY_OVERRIDABLE'})

class SanitizeRigifyProperties(bpy.types.PropertyGroup):
    """
    Collection property holding properties of a unit.
    A unit is : rigify rig + game-ready rig + parented meshes
    Always put on the rigify rig
    """
    generated_rig : bpy.props.PointerProperty(type = bpy.types.Object, name = "Generated rig", poll = is_generated_rig, override = {'LIBRARY_OVERRIDABLE'}, description = "Generated game-ready rig")
    have_additional_bones : bpy.props.BoolProperty(name = "Have additional bones", default = False, override = {'LIBRARY_OVERRIDABLE'})
    additional_bones : bpy.props.CollectionProperty(type = SanitizeRigifyBoneProperty, name = "Additional bones", override = {'LIBRARY_OVERRIDABLE'}, description = "List of Bones to keep in created Armature regardless of deform status")
    additional_bones_index : bpy.props.IntProperty(name = "Index for Additional bones", default = 0, override = {'LIBRARY_OVERRIDABLE'})
    additional_bones_toadd : bpy.props.StringProperty(name = "Additional bone to add", override = {'LIBRARY_OVERRIDABLE'})
    export_mode : bpy.props.EnumProperty(
        items=[
            ('ARMATURE', 'Armature', 'Armature only (with meshes)', 'ARMATURE_DATA', 1),
            ('NLA', 'NLA Animations', 'NLA Animations only', 'NLA', 2),
            ('ALL', 'All', 'Armature and NLA animations', 'OUTLINER_OB_ARMATURE', 3)
        ],
        name="Export mode",
        default='ALL',
        override = {'LIBRARY_OVERRIDABLE'}
    )
    armature_name : bpy.props.StringProperty(name = "Armature name", default = "Armature", override = {'LIBRARY_OVERRIDABLE'}, description = "Name of the armature data for this rig when exported")
    disconnect_all_bones : bpy.props.BoolProperty(name = "Disconnect all bones", default = True, override = {'LIBRARY_OVERRIDABLE'})
    recenter : bpy.props.BoolProperty(name = "Recenter rig", default = True, override = {'LIBRARY_OVERRIDABLE'})
    animation_naming : bpy.props.EnumProperty(
        items=[
            ('TRACK', 'Track', 'Use name of track', 'ARMATURE_DATA', 1),
            ('STRIP', 'First Strip', 'Use name of first strip in track', 'NLA', 2),
        ],
        name="Animation naming",
        default='STRIP',
        override = {'LIBRARY_OVERRIDABLE'}
    )
    
    def set_path(self, value):
        self["path"] = value
        self["path_owner"] = self.id_data.name
    def get_path(self):
        object_owner = self.id_data
        if not self.get("path") or not self.get("path_owner") or (object_owner.name != self.path_owner):
            # reset path if path_owner is not us
            self["path"] = "//"
            self["path_owner"] = object_owner.name
            print("Path was reset")
        return self["path"]
    path : bpy.props.StringProperty(name = "Path", default = "//", subtype = 'DIR_PATH', set = set_path, get = get_path, override = {'LIBRARY_OVERRIDABLE'}, description = "Export path for this rig. Renaming the rig will reset")
    # Used to reset path when duplicating rigs. If this is not the same as the object's name then reset path
    path_owner : bpy.props.StringProperty(name = "Path owner", default = "", options = {'HIDDEN'}, override = {'LIBRARY_OVERRIDABLE'})

def register():
    bpy.types.Object.sr_rigify_properties = bpy.props.PointerProperty(type = SanitizeRigifyProperties, override = {'LIBRARY_OVERRIDABLE'})
    bpy.types.Object.sr_origin = bpy.props.PointerProperty(type = bpy.types.Object, poll = is_rigify, override = {'LIBRARY_OVERRIDABLE'}, description = "Origin rigify")
    bpy.types.Scene.sr_current_rigify = bpy.props.PointerProperty(type = bpy.types.Object, poll = is_rigify, override = {'LIBRARY_OVERRIDABLE'}, description = "Current rigify")
    bpy.types.Bone.sr_is_prefixed = bpy.props.BoolProperty(default = False, override = {'LIBRARY_OVERRIDABLE'})
    # handler to update current_rigify
    bpy.app.handlers.depsgraph_update_post.append(depsgraph_update_handler)

def unregister():
    del bpy.types.Object.sr_rigify_properties
    del bpy.types.Object.sr_origin
    del bpy.types.Scene.sr_current_rigify
    del bpy.types.Bone.sr_is_prefixed
    # handler to update current_rigify
    bpy.app.handlers.depsgraph_update_post.remove(depsgraph_update_handler)
